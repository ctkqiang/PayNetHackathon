import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import 'package:pfm_paynet/controllers/database_handler.dart';
import 'package:pfm_paynet/views/widgets/animated_snackbar.widget.dart';

class SetupPage extends StatefulWidget {
  final String? name;
  const SetupPage({super.key, this.name});

  @override
  State<SetupPage> createState() => _SetupPageState();
}

class _SetupPageState extends State<SetupPage>
    with SingleTickerProviderStateMixin {
  final logger = Logger();
  final databaseHandler = DatabaseHandler.create();
  final Map<String, String> options = {
    'Expenses': 'Costs incurred for business operations.',
    'Income': 'Revenue generated by activities.',
    'Debts': 'Financial obligations owed to others.',
    'Cashflow': 'Money movement in and out of the business.',
    'Net Worth': 'Difference between assets and liabilities.',
    'Persistency Ratio': 'Ability to sustain finances over time.',
    'Wealth Accumulation Ratio': 'Proportion of accumulated wealth.',
    'Emergency Funds': 'Savings for unexpected emergencies.',
    'Insurances': 'Coverage against financial losses.',
    'Investments': 'Assets bought for potential returns.'
  };

  // Map of options to their icons
  final Map<String, IconData> optionIcons = {
    'Expenses': Icons.money_off,
    'Income': Icons.attach_money,
    'Debts': Icons.credit_card,
    'Cashflow': Icons.compare_arrows,
    'Net Worth': Icons.pie_chart,
    'Persistency Ratio': Icons.percent,
    'Wealth Accumulation Ratio': Icons.savings,
    'Emergency Funds': Icons.health_and_safety,
    'Insurances': Icons.security,
    'Investments': Icons.trending_up,
  };

  List<bool> _selectedOptions = [];
  List<String> selected = [];
  AnimationController? _animationController;
  List<Animation<double>> _fadeAnimations = [];
  List<Animation<Offset>> _slideAnimations = [];

  void selectUserPreferences({bool? choices, int? index}) {
    if (super.mounted) {
      super.setState(() {
        _selectedOptions[index!] = choices ?? false;

        String optionName = options.keys.elementAt(index);

        if (kDebugMode) {
          logger.i('${choices! ? "Selected" : "Unselected"}: $optionName');
        }

        for (int i = 0; i < _selectedOptions.length; i++) {
          if (_selectedOptions[i]) selected.add(options.keys.elementAt(i));
        }
      });
    }
  }

  Future<void> setUserPreferences() async {
    if (super.mounted) {
      try {
        selected.removeRange(0, 1);

        // Count the number of selected options
        int selectedCount =
            _selectedOptions.where((isSelected) => isSelected).length;

        if (kDebugMode) {
          if (selected.isEmpty) {
            logger.e('[x] Selected Choices: None');
          }

          logger.d('[x] Selected Choices: $selected');
        }

        if (selectedCount >= 2 || selectedCount != 0) {
          // Save selected choices into localStorage
          databaseHandler.localStorage.write('choices', selected);

          for (int i = 0; i < _selectedOptions.length; i++) {
            // Get the option key and its selection state
            String optionKey = options.keys.elementAt(i);
            bool isSelected = _selectedOptions[i];

            // Save each option as a key with its state (true/false)
            databaseHandler.localStorage.write(optionKey, isSelected);

            final userOptions = databaseHandler.localStorage.read(optionKey);

            if (userOptions.toString().isNotEmpty) {
              Navigator.pushReplacementNamed(context, '/main');
            }

            logger.i(
              '${isSelected ? "Selected" : "Unselected"}: $optionKey saved to local storage.',
            );
          }
        } else {
          showCustomSnackBar(
            context,
            "Please select at least 2 options to proceed.",
          );
        }
      } catch (e) {
        logger.e("Error saving preferences: $e");

        if (e.toString().contains('Invalid value: Only valid value is 0: 1')) {
          showCustomSnackBar(
            context,
            "Please select at least 2 options to proceed.",
          );
        }
      } finally {
        logger.i('All preferences saved to local storage.');
      }
    }
  }

  @override
  void initState() {
    super.initState();

    // Initialize selected options
    _selectedOptions = List.generate(options.length, (index) => false);

    // Initialize animation controller
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    final double intervalStep = 1.0 / options.length;

    // Create individual animations for each item
    _fadeAnimations = List.generate(
      options.length,
      (index) => Tween<double>(
        begin: 0.0,
        end: 1.0,
      ).animate(
        CurvedAnimation(
          parent: _animationController!,
          curve: Interval(
            index * intervalStep,
            (index * intervalStep) + intervalStep,
            curve: Curves.easeOut,
          ),
        ),
      ),
    );

    _slideAnimations = List.generate(
      options.length,
      (index) => Tween<Offset>(
        begin: const Offset(0.3, 1),
        end: Offset.zero,
      ).animate(
        CurvedAnimation(
          parent: _animationController!,
          curve: Interval(
            index * intervalStep,
            (index * intervalStep) + intervalStep,
            curve: Curves.easeOut,
          ),
        ),
      ),
    );

    _animationController!.forward();
  }

  @override
  void dispose() {
    _animationController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_animationController == null) {
      return const Center(child: CircularProgressIndicator());
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Design Your Experience'),
        actions: [
          IconButton(
            icon: Icon(
              Icons.arrow_circle_right_outlined,
              color: Theme.of(context).iconTheme.color!.withOpacity(0.7),
              size: 35,
            ),
            onPressed: setUserPreferences,
          )
        ],
        forceMaterialTransparency: true,
        bottomOpacity: 0.0,
      ),
      body: RefreshIndicator(
        onRefresh: () async => _animationController!.forward(),
        child: Padding(
          padding: const EdgeInsets.all(10.0),
          child: ListView.builder(
            itemCount: options.length,
            padding: const EdgeInsets.only(top: 8, bottom: 8),
            itemBuilder: (context, index) {
              String optionKey = options.keys.elementAt(index);
              String explanation = options[optionKey]!;

              return AnimatedBuilder(
                animation: _animationController!,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnimations[index].value,
                    child: SlideTransition(
                      position: _slideAnimations[index],
                      child: Padding(
                        padding: const EdgeInsets.symmetric(
                          vertical: 2.5,
                          horizontal: 5.0,
                        ),
                        child: Card(
                          elevation: 2,
                          borderOnForeground: true,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(25),
                          ),
                          child: ListTile(
                            enableFeedback: true,
                            leading: CircleAvatar(
                              radius: 20,
                              child: Icon(
                                optionIcons[optionKey],
                                size: 20,
                              ),
                            ),
                            title: Text(
                              optionKey,
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            subtitle: Text(explanation),
                            trailing: Checkbox(
                              value: _selectedOptions[index],
                              onChanged: (b) => selectUserPreferences(
                                choices: b,
                                index: index,
                              ),
                              side: BorderSide(
                                style: BorderStyle.solid,
                                width: 1.6,
                                color: Theme.of(context).iconTheme.color!,
                              ),
                            ),
                            contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16,
                            ),
                          ),
                        ),
                      ),
                    ),
                  );
                },
              );
            },
          ),
        ),
      ),
    );
  }
}
